<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nvcore &#8212; QUSIM 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=61cd365c" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=8d563738"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for nvcore</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">NV Center System with Full Noise Integration and Lindblad Evolution</span>

<span class="sd">This module implements a complete nitrogen-vacancy (NV) center quantum system simulation</span>
<span class="sd">including comprehensive noise modeling, open quantum system dynamics, and pulse control.</span>

<span class="sd">The module provides:</span>
<span class="sd">    - Complete spin-1 operator algebra for NV centers</span>
<span class="sd">    - Hamiltonian construction with zero-field splitting and Zeeman effects</span>
<span class="sd">    - Integration of multiple noise sources (C13 bath, charge noise, thermal effects, etc.)</span>
<span class="sd">    - Lindblad master equation evolution for open system dynamics</span>
<span class="sd">    - Microwave pulse sequence control</span>
<span class="sd">    - Common experimental protocols (Ramsey, echo sequences)</span>
<span class="sd">    - Visualization and analysis tools</span>

<span class="sd">Key Features:</span>
<span class="sd">    - Physically accurate modeling based on experimental parameters</span>
<span class="sd">    - Flexible noise configuration for different experimental conditions</span>
<span class="sd">    - Support for arbitrary pulse sequences</span>
<span class="sd">    - Efficient numerical integration with adaptive timesteps</span>
<span class="sd">    - Built-in measurement protocols for T2*, T1 characterization</span>

<span class="sd">Examples:</span>
<span class="sd">    Basic usage with default room temperature noise:</span>
<span class="sd">        &gt;&gt;&gt; nv = create_room_temperature_nv()</span>
<span class="sd">        &gt;&gt;&gt; rho0 = np.outer(nv.states[&#39;ms0&#39;], nv.states[&#39;ms0&#39;].conj())</span>
<span class="sd">        &gt;&gt;&gt; times, rhos = nv.evolve(rho0, (0, 1e-6))</span>
<span class="sd">        </span>
<span class="sd">    Custom noise configuration:</span>
<span class="sd">        &gt;&gt;&gt; config = NoiseConfiguration()</span>
<span class="sd">        &gt;&gt;&gt; config.enable_c13_bath = True</span>
<span class="sd">        &gt;&gt;&gt; config.enable_charge_noise = False</span>
<span class="sd">        &gt;&gt;&gt; nv = NVSystem(B_field=[0, 0, 0.01], noise_config=config)</span>
<span class="sd">        </span>
<span class="sd">    Ramsey sequence measurement:</span>
<span class="sd">        &gt;&gt;&gt; tau_values, coherences = nv.simulate_t2_measurement()</span>
<span class="sd">        </span>
<span class="sd">Author: QUSIM Development Team</span>
<span class="sd">License: MIT</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="c1"># Add helper path for noise sources</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;helper&#39;</span><span class="p">))</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;modules&#39;</span><span class="p">))</span>

<span class="kn">from</span> <span class="nn">noise</span> <span class="kn">import</span> <span class="n">NoiseGenerator</span><span class="p">,</span> <span class="n">NoiseConfiguration</span>
<span class="kn">from</span> <span class="nn">noise_sources</span> <span class="kn">import</span> <span class="n">SYSTEM</span>


<div class="viewcode-block" id="NVSpinOperators">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSpinOperators">[docs]</a>
<span class="k">class</span> <span class="nc">NVSpinOperators</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Spin operators for NV center electronic ground state (S=1 system).</span>
<span class="sd">    </span>
<span class="sd">    This class implements the complete set of spin-1 operators for the nitrogen-vacancy</span>
<span class="sd">    center&#39;s electronic ground state triplet. The operators are represented in the </span>
<span class="sd">    standard |ms=-1,0,+1⟩ basis, where ms is the spin projection along the NV axis.</span>
<span class="sd">    </span>
<span class="sd">    The spin operators satisfy the standard angular momentum commutation relations:</span>
<span class="sd">        [Si, Sj] = i·εijk·Sk</span>
<span class="sd">        </span>
<span class="sd">    where εijk is the Levi-Civita symbol.</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        dim (int): Dimension of the Hilbert space (3 for spin-1)</span>
<span class="sd">        Sx (np.ndarray): Spin-x operator matrix (3x3 complex)</span>
<span class="sd">        Sy (np.ndarray): Spin-y operator matrix (3x3 complex)</span>
<span class="sd">        Sz (np.ndarray): Spin-z operator matrix (3x3 complex)</span>
<span class="sd">        S_plus (np.ndarray): Raising operator S+ = Sx + i·Sy</span>
<span class="sd">        S_minus (np.ndarray): Lowering operator S- = Sx - i·Sy</span>
<span class="sd">        Sx2 (np.ndarray): Squared spin-x operator Sx²</span>
<span class="sd">        Sy2 (np.ndarray): Squared spin-y operator Sy²</span>
<span class="sd">        Sz2 (np.ndarray): Squared spin-z operator Sz²</span>
<span class="sd">        I (np.ndarray): Identity operator (3x3)</span>
<span class="sd">        operators (dict): Dictionary mapping operator names to matrices</span>
<span class="sd">        </span>
<span class="sd">    Notes:</span>
<span class="sd">        - All operators are Hermitian (except S+ and S-)</span>
<span class="sd">        - The operators form a complete basis for observables</span>
<span class="sd">        - Matrix elements follow Condon-Shortley phase conventions</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; ops = NVSpinOperators()</span>
<span class="sd">        &gt;&gt;&gt; # Verify commutation relation [Sx, Sy] = i·Sz</span>
<span class="sd">        &gt;&gt;&gt; commutator = ops.Sx @ ops.Sy - ops.Sy @ ops.Sx</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(commutator, 1j * ops.Sz)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; # Check total spin S² = 2 for spin-1</span>
<span class="sd">        &gt;&gt;&gt; S_squared = ops.Sx2 + ops.Sy2 + ops.Sz2</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(S_squared, 2 * ops.I)</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="NVSpinOperators.__init__">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSpinOperators.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize spin-1 operators for the NV center ground state.</span>
<span class="sd">        </span>
<span class="sd">        Constructs all spin operators in the |ms=-1,0,+1⟩ basis following</span>
<span class="sd">        standard angular momentum algebra conventions. The basis states are</span>
<span class="sd">        ordered as |ms=-1⟩, |ms=0⟩, |ms=+1⟩.</span>
<span class="sd">        </span>
<span class="sd">        The operator matrix elements are computed using:</span>
<span class="sd">            &lt;ms&#39;|S±|ms&gt; = √[S(S+1) - ms(ms±1)]·δ(ms&#39;,ms±1)</span>
<span class="sd">            &lt;ms&#39;|Sz|ms&gt; = ms·δ(ms&#39;,ms)</span>
<span class="sd">            </span>
<span class="sd">        where S=1 for the NV ground state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Dimension of spin-1 Hilbert space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
        
        <span class="c1"># Standard spin-1 operators in |ms=-1,0,+1⟩ basis</span>
        <span class="c1"># These satisfy [Si, Sj] = i*εijk*Sk with proper normalization</span>
        
        <span class="c1"># Construct from S± operators first for consistency</span>
        <span class="n">S_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="n">S_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Sx = (S+ + S-)/2, Sy = (S+ - S-)/(2i)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_plus</span> <span class="o">+</span> <span class="n">S_minus</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sy</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_plus</span> <span class="o">-</span> <span class="n">S_minus</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">Sz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Raising and lowering operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sy</span>
        
        <span class="c1"># Squared operators (useful for strain terms)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sy2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sy</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sz2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sz</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sz</span>
        
        <span class="c1"># Identity operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Dictionary for convenient access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;Sx&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span><span class="p">,</span> <span class="s1">&#39;Sy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sy</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sz</span><span class="p">,</span>
            <span class="s1">&#39;S+&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_plus</span><span class="p">,</span> <span class="s1">&#39;S-&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_minus</span><span class="p">,</span>
            <span class="s1">&#39;Sx2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx2</span><span class="p">,</span> <span class="s1">&#39;Sy2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sy2</span><span class="p">,</span> <span class="s1">&#39;Sz2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sz2</span><span class="p">,</span>
            <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span>
        <span class="p">}</span></div>

        
<div class="viewcode-block" id="NVSpinOperators.verify_algebra">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSpinOperators.verify_algebra">[docs]</a>
    <span class="k">def</span> <span class="nf">verify_algebra</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that operators satisfy correct algebraic relations.</span>
<span class="sd">        </span>
<span class="sd">        Checks:</span>
<span class="sd">            - Hermiticity of spin operators</span>
<span class="sd">            - Commutation relations</span>
<span class="sd">            - Total spin S² = S(S+1) = 2</span>
<span class="sd">            - Trace properties</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            bool: True if all checks pass</span>
<span class="sd">            </span>
<span class="sd">        Raises:</span>
<span class="sd">            AssertionError: If any algebraic relation is violated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check Hermiticity</span>
        <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Sx&#39;</span><span class="p">,</span> <span class="s1">&#39;Sy&#39;</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">]:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op_name</span><span class="si">}</span><span class="s2"> not Hermitian&quot;</span>
            
        <span class="c1"># Check commutation relations</span>
        <span class="n">comm_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sy</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sy</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">comm_xy</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sz</span><span class="p">),</span> <span class="s2">&quot;[Sx,Sy] ≠ i·Sz&quot;</span>
        
        <span class="c1"># Check S² = 2</span>
        <span class="n">S_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sx2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sy2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sz2</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">S_squared</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">),</span> <span class="s2">&quot;S² ≠ 2&quot;</span>
        
        <span class="k">return</span> <span class="kc">True</span></div>
</div>



<div class="viewcode-block" id="NVSystemHamiltonian">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystemHamiltonian">[docs]</a>
<span class="k">class</span> <span class="nc">NVSystemHamiltonian</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NV center Hamiltonian with comprehensive noise integration.</span>
<span class="sd">    </span>
<span class="sd">    This class constructs and manages the full Hamiltonian for an NV center including</span>
<span class="sd">    all relevant physical interactions and noise sources. The Hamiltonian consists of:</span>
<span class="sd">    </span>
<span class="sd">    1. Zero-field splitting (ZFS) from spin-spin interaction</span>
<span class="sd">    2. Zeeman interaction with external magnetic fields  </span>
<span class="sd">    3. Strain-induced splitting</span>
<span class="sd">    4. Time-dependent noise from various environmental sources</span>
<span class="sd">    </span>
<span class="sd">    The general form of the Hamiltonian is:</span>
<span class="sd">        H = H_ZFS + H_Zeeman + H_strain + H_noise(t)</span>
<span class="sd">        </span>
<span class="sd">    where:</span>
<span class="sd">        H_ZFS = D·(Sz² - 2/3·I) + E·(Sx² - Sy²)</span>
<span class="sd">        H_Zeeman = γe·B·S</span>
<span class="sd">        H_noise(t) = Σ_i noise_i(t)·O_i</span>
<span class="sd">        </span>
<span class="sd">    with D ≈ 2.87 GHz the axial ZFS parameter, E the transverse strain parameter,</span>
<span class="sd">    γe ≈ 28 GHz/T the electron gyromagnetic ratio, and O_i appropriate operators</span>
<span class="sd">    for each noise source.</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        spin_ops (NVSpinOperators): Complete set of spin operators</span>
<span class="sd">        B_static (np.ndarray): Static magnetic field vector [Bx, By, Bz] in Tesla</span>
<span class="sd">        noise_gen (NoiseGenerator): Generator for time-dependent noise fields</span>
<span class="sd">        D (float): Zero-field splitting parameter in Hz (typically 2.87 GHz)</span>
<span class="sd">        E (float): Strain-induced splitting parameter in Hz (typically &lt; 10 MHz)</span>
<span class="sd">        gamma_e (float): Electron gyromagnetic ratio in Hz/T (28.024 GHz/T)</span>
<span class="sd">        </span>
<span class="sd">    Parameters:</span>
<span class="sd">        B_field: Static magnetic field components in Tesla</span>
<span class="sd">        noise_gen: Noise generator instance for environmental effects</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # NV in 10 mT field along z-axis</span>
<span class="sd">        &gt;&gt;&gt; B = np.array([0, 0, 0.01])</span>
<span class="sd">        &gt;&gt;&gt; ham = NVSystemHamiltonian(B_field=B)</span>
<span class="sd">        &gt;&gt;&gt; H_static = ham.get_static_hamiltonian()</span>
<span class="sd">        &gt;&gt;&gt; eigenvalues = np.linalg.eigvalsh(H_static) / (2*np.pi*1e9)  # in GHz</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Energy levels: {eigenvalues}&quot;)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Add noise effects</span>
<span class="sd">        &gt;&gt;&gt; noise_gen = NoiseGenerator(NoiseConfiguration())</span>
<span class="sd">        &gt;&gt;&gt; ham_noisy = NVSystemHamiltonian(B_field=B, noise_gen=noise_gen)</span>
<span class="sd">        &gt;&gt;&gt; H_total = ham_noisy.get_total_hamiltonian()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="NVSystemHamiltonian.__init__">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystemHamiltonian.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">noise_gen</span><span class="p">:</span> <span class="n">NoiseGenerator</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize NV system Hamiltonian with field and noise configuration.</span>
<span class="sd">        </span>
<span class="sd">        Creates the Hamiltonian manager with specified static magnetic field and</span>
<span class="sd">        noise generator. All physical parameters are loaded from the system</span>
<span class="sd">        configuration file.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            B_field: Static magnetic field vector [Bx, By, Bz] in Tesla.</span>
<span class="sd">                    Must be a 3-element array-like object.</span>
<span class="sd">                    If None, zero field is assumed.</span>
<span class="sd">            noise_gen: NoiseGenerator instance for time-dependent effects.</span>
<span class="sd">                      If None, no noise is included (ideal system).</span>
<span class="sd">                      </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If B_field has incorrect shape or invalid values.</span>
<span class="sd">            TypeError: If noise_gen is not a NoiseGenerator instance.</span>
<span class="sd">            </span>
<span class="sd">        Notes:</span>
<span class="sd">            - Field values should be in Tesla (not Gauss)</span>
<span class="sd">            - Typical lab fields are 0.001-1 T</span>
<span class="sd">            - The NV z-axis is along the [111] crystal direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize spin operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span> <span class="o">=</span> <span class="n">NVSpinOperators</span><span class="p">()</span>
        
        <span class="c1"># Set magnetic field</span>
        <span class="k">if</span> <span class="n">B_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">B_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">B_field</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">B_field</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;B_field must be 3D vector, got shape </span><span class="si">{</span><span class="n">B_field</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B_static</span> <span class="o">=</span> <span class="n">B_field</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B_static</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            
        <span class="c1"># Set noise generator</span>
        <span class="k">if</span> <span class="n">noise_gen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_gen</span><span class="p">,</span> <span class="n">NoiseGenerator</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;noise_gen must be a NoiseGenerator instance&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise_gen</span> <span class="o">=</span> <span class="n">noise_gen</span>
        
        <span class="c1"># Load NV center parameters from system configuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">SYSTEM</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="s1">&#39;nv_center&#39;</span><span class="p">,</span> <span class="s1">&#39;d_gs&#39;</span><span class="p">)</span>  <span class="c1"># ZFS parameter [Hz]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="n">SYSTEM</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="s1">&#39;nv_center&#39;</span><span class="p">,</span> <span class="s1">&#39;e_gs&#39;</span><span class="p">)</span>  <span class="c1"># Strain parameter [Hz]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_e</span> <span class="o">=</span> <span class="n">SYSTEM</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="s1">&#39;nv_center&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma_e&#39;</span><span class="p">)</span>  <span class="c1"># Gyromagnetic ratio [Hz/T]</span></div>

        
<div class="viewcode-block" id="NVSystemHamiltonian.get_static_hamiltonian">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystemHamiltonian.get_static_hamiltonian">[docs]</a>
    <span class="k">def</span> <span class="nf">get_static_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the static (time-independent) part of the Hamiltonian.</span>
<span class="sd">        </span>
<span class="sd">        Builds the static Hamiltonian including zero-field splitting,</span>
<span class="sd">        strain effects, and static Zeeman interaction. This represents</span>
<span class="sd">        the &quot;bare&quot; NV Hamiltonian without environmental noise.</span>
<span class="sd">        </span>
<span class="sd">        The static Hamiltonian is:</span>
<span class="sd">            H_static = 2π·D·(Sz² - 2/3·I) + 2π·E·(Sx² - Sy²) + 2π·γe·B·S</span>
<span class="sd">            </span>
<span class="sd">        where the factor of 2π converts from Hz to angular frequency units.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: 3x3 complex Hamiltonian matrix in units of rad/s.</span>
<span class="sd">                       Eigenvalues give energies E_i such that |ψ(t)⟩ = e^(-iE_i·t/ℏ)|ψ_i⟩</span>
<span class="sd">            </span>
<span class="sd">        Notes:</span>
<span class="sd">            - The Hamiltonian is Hermitian by construction</span>
<span class="sd">            - In zero field, eigenstates are |0⟩ and (|+1⟩±|-1⟩)/√2</span>
<span class="sd">            - Energy scale is dominated by D ≈ 2.87 GHz</span>
<span class="sd">            - Strain term E breaks the |±1⟩ degeneracy</span>
<span class="sd">            </span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; ham = NVSystemHamiltonian()</span>
<span class="sd">            &gt;&gt;&gt; H = ham.get_static_hamiltonian()</span>
<span class="sd">            &gt;&gt;&gt; # Check Hermiticity</span>
<span class="sd">            &gt;&gt;&gt; np.allclose(H, H.conj().T)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; # Get transition frequencies</span>
<span class="sd">            &gt;&gt;&gt; E = np.linalg.eigvalsh(H)</span>
<span class="sd">            &gt;&gt;&gt; freq_01 = (E[1] - E[0]) / (2*np.pi*1e9)  # in GHz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">H_static</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Zero-field splitting: D(Sz² - 2/3·I)</span>
        <span class="c1"># This is the dominant term, splitting |0⟩ from |±1⟩ by ~2.87 GHz</span>
        <span class="n">H_static</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">Sz2</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
        
        <span class="c1"># Strain term: E(Sx² - Sy²)</span>
        <span class="c1"># This breaks the degeneracy between |+1⟩ and |-1⟩ states</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">H_static</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">Sx2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">Sy2</span><span class="p">)</span>
        
        <span class="c1"># Static Zeeman effect: γe·B·S</span>
        <span class="c1"># Linear in field strength, typically small compared to D</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_static</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">H_static</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_e</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B_static</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">Sx</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B_static</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">Sy</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B_static</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">Sz</span>
            <span class="p">)</span>
            
        <span class="k">return</span> <span class="n">H_static</span></div>

    
<div class="viewcode-block" id="NVSystemHamiltonian.get_noise_hamiltonian">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystemHamiltonian.get_noise_hamiltonian">[docs]</a>
    <span class="k">def</span> <span class="nf">get_noise_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> 
                            <span class="n">include_sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the noise contribution to the Hamiltonian at time t.</span>
<span class="sd">        </span>
<span class="sd">        Computes the time-dependent part of the Hamiltonian arising from</span>
<span class="sd">        environmental noise sources. Each noise source contributes terms</span>
<span class="sd">        of the form noise_field(t)·operator.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            t: Time point in seconds at which to evaluate noise.</span>
<span class="sd">            include_sources: List of noise sources to include.</span>
<span class="sd">                           Options: [&#39;c13_bath&#39;, &#39;charge_noise&#39;, &#39;temperature&#39;,</span>
<span class="sd">                                    &#39;johnson&#39;, &#39;external_field&#39;, &#39;strain&#39;,</span>
<span class="sd">                                    &#39;microwave&#39;, &#39;optical&#39;]</span>
<span class="sd">                           If None, all enabled sources are included.</span>
<span class="sd">                           </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: 3x3 complex noise Hamiltonian matrix in rad/s.</span>
<span class="sd">                       This should be added to the static Hamiltonian.</span>
<span class="sd">                       </span>
<span class="sd">        Notes:</span>
<span class="sd">            - Noise is sampled from the noise generator at time t</span>
<span class="sd">            - Magnetic noise couples through Zeeman interaction</span>
<span class="sd">            - Electric noise can couple through strain effects</span>
<span class="sd">            - The noise Hamiltonian is Hermitian</span>
<span class="sd">            </span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Get noise at t=1 μs with only C13 bath</span>
<span class="sd">            &gt;&gt;&gt; H_noise = ham.get_noise_hamiltonian(t=1e-6, include_sources=[&#39;c13_bath&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_gen</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_gen</span><span class="o">.</span><span class="n">get_noise_hamiltonian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">operators</span><span class="p">,</span> 
            <span class="n">include_sources</span>
        <span class="p">)</span></div>

    
<div class="viewcode-block" id="NVSystemHamiltonian.get_total_hamiltonian">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystemHamiltonian.get_total_hamiltonian">[docs]</a>
    <span class="k">def</span> <span class="nf">get_total_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                            <span class="n">include_noise_sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the total Hamiltonian including static and noise terms.</span>
<span class="sd">        </span>
<span class="sd">        Constructs the complete time-dependent Hamiltonian:</span>
<span class="sd">            H_total(t) = H_static + H_noise(t)</span>
<span class="sd">            </span>
<span class="sd">        This is the Hamiltonian that enters the Schrödinger or master equation.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            t: Time in seconds at which to evaluate the Hamiltonian.</span>
<span class="sd">            include_noise_sources: Specific noise sources to include.</span>
<span class="sd">                                 If None, all enabled sources are used.</span>
<span class="sd">                                 </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: 3x3 complex total Hamiltonian matrix in rad/s.</span>
<span class="sd">            </span>
<span class="sd">        See Also:</span>
<span class="sd">            get_static_hamiltonian: For the time-independent part</span>
<span class="sd">            get_noise_hamiltonian: For the noise contribution only</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">H_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_static_hamiltonian</span><span class="p">()</span>
        <span class="n">H_total</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_noise_hamiltonian</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">include_noise_sources</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H_total</span></div>
</div>



<div class="viewcode-block" id="NVLindblad">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVLindblad">[docs]</a>
<span class="k">class</span> <span class="nc">NVLindblad</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lindblad master equation evolution for NV center open quantum dynamics.</span>
<span class="sd">    </span>
<span class="sd">    This class implements the Lindblad (quantum master) equation for modeling</span>
<span class="sd">    the evolution of an NV center as an open quantum system. The Lindblad</span>
<span class="sd">    equation captures both coherent evolution and incoherent processes like</span>
<span class="sd">    relaxation and decoherence:</span>
<span class="sd">    </span>
<span class="sd">        dρ/dt = -i/ℏ[H,ρ] + Σ_k γ_k·(L_k·ρ·L_k† - {L_k†·L_k,ρ}/2)</span>
<span class="sd">        </span>
<span class="sd">    where ρ is the density matrix, H is the Hamiltonian, L_k are Lindblad</span>
<span class="sd">    operators describing dissipation channels, and γ_k are the corresponding</span>
<span class="sd">    rates.</span>
<span class="sd">    </span>
<span class="sd">    The dissipation terms model various decoherence mechanisms:</span>
<span class="sd">        - Energy relaxation (T1 processes)</span>
<span class="sd">        - Pure dephasing (T2* processes)  </span>
<span class="sd">        - Spectral diffusion from noise baths</span>
<span class="sd">        - Measurement backaction</span>
<span class="sd">        </span>
<span class="sd">    Attributes:</span>
<span class="sd">        hamiltonian (NVSystemHamiltonian): System Hamiltonian manager</span>
<span class="sd">        spin_ops (NVSpinOperators): Spin operator matrices</span>
<span class="sd">        default_T1 (float): Default longitudinal relaxation time</span>
<span class="sd">        default_T2 (float): Default transverse coherence time</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Create Lindblad evolver with noise</span>
<span class="sd">        &gt;&gt;&gt; ham = NVSystemHamiltonian(B_field=[0,0,0.01])</span>
<span class="sd">        &gt;&gt;&gt; lindblad = NVLindblad(ham)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Evolve from initial state</span>
<span class="sd">        &gt;&gt;&gt; rho0 = np.diag([0, 1, 0])  # |ms=0⟩ state</span>
<span class="sd">        &gt;&gt;&gt; times, rhos = lindblad.evolve(rho0, (0, 1e-6))</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Check decoherence</span>
<span class="sd">        &gt;&gt;&gt; purity = [np.real(np.trace(rho @ rho)) for rho in rhos]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="NVLindblad.__init__">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVLindblad.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">:</span> <span class="n">NVSystemHamiltonian</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize Lindblad evolution with given Hamiltonian.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            hamiltonian: NVSystemHamiltonian instance containing the</span>
<span class="sd">                        system Hamiltonian and noise configuration.</span>
<span class="sd">                        </span>
<span class="sd">        Notes:</span>
<span class="sd">            The Lindblad operators are determined by the noise sources</span>
<span class="sd">            enabled in the Hamiltonian&#39;s noise generator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">hamiltonian</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="o">.</span><span class="n">spin_ops</span>
        
        <span class="c1"># Default relaxation parameters if not provided by noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_T1</span> <span class="o">=</span> <span class="n">SYSTEM</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="s1">&#39;nv_center&#39;</span><span class="p">,</span> <span class="s1">&#39;typical_t1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_T2</span> <span class="o">=</span> <span class="n">SYSTEM</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="s1">&#39;nv_center&#39;</span><span class="p">,</span> <span class="s1">&#39;typical_t2&#39;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="NVLindblad.get_lindblad_operators">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVLindblad.get_lindblad_operators">[docs]</a>
    <span class="k">def</span> <span class="nf">get_lindblad_operators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                             <span class="n">include_sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get Lindblad operators and rates for dissipation.</span>
<span class="sd">        </span>
<span class="sd">        Constructs the set of Lindblad operators L_k and rates γ_k that</span>
<span class="sd">        describe dissipation channels. These can come from:</span>
<span class="sd">        </span>
<span class="sd">        1. Noise-induced decoherence (from noise generator)</span>
<span class="sd">        2. Phenomenological relaxation (T1 processes)</span>
<span class="sd">        3. Phenomenological dephasing (T2* processes)</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            include_sources: List of noise sources to include in dissipation.</span>
<span class="sd">                           If None, all enabled sources are used.</span>
<span class="sd">                           </span>
<span class="sd">        Returns:</span>
<span class="sd">            List[Tuple[np.ndarray, float]]: List of (operator, rate) pairs</span>
<span class="sd">                where operator is a 3x3 complex matrix and rate is in Hz.</span>
<span class="sd">                </span>
<span class="sd">        Notes:</span>
<span class="sd">            - Rates are given as γ such that the decoherence rate is γ</span>
<span class="sd">            - For thermal relaxation: L = S_- with γ = 1/T1</span>
<span class="sd">            - For pure dephasing: L = Sz with γ = 1/T2φ</span>
<span class="sd">            - T2φ is the pure dephasing time: 1/T2 = 1/(2T1) + 1/T2φ</span>
<span class="sd">            </span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; ops = lindblad.get_lindblad_operators()</span>
<span class="sd">            &gt;&gt;&gt; for L, gamma in ops:</span>
<span class="sd">            ...     print(f&quot;Rate: {gamma:.2e} Hz&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lindblad_ops</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Get noise-induced Lindblad operators</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">noise_gen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">noise_ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">noise_gen</span><span class="o">.</span><span class="n">get_lindblad_operators</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">operators</span><span class="p">,</span>
                <span class="n">include_sources</span>
            <span class="p">)</span>
            <span class="n">lindblad_ops</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">noise_ops</span><span class="p">)</span>
        
        <span class="c1"># Check if we need to add phenomenological relaxation</span>
        <span class="n">has_thermal</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="s1">&#39;thermal&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">lindblad_ops</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_thermal</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_T1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Add T1 relaxation: decay from |±1⟩ to |0⟩</span>
            <span class="n">gamma_1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_T1</span>
            <span class="c1"># Note: simplified model, could be extended for temperature dependence</span>
            <span class="n">lindblad_ops</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">S_minus</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma_1</span><span class="p">)))</span>
            
        <span class="c1"># Check if we need to add phenomenological dephasing  </span>
        <span class="n">has_dephasing</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="s1">&#39;dephasing&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">lindblad_ops</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_dephasing</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_T2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Add pure dephasing</span>
            <span class="c1"># T2 includes both relaxation and pure dephasing: 1/T2 = 1/(2T1) + 1/T2φ</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_T1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gamma_phi</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">default_T2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">default_T1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gamma_phi</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">default_T2</span>
                
            <span class="k">if</span> <span class="n">gamma_phi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lindblad_ops</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">Sz</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma_phi</span><span class="p">)))</span>
            
        <span class="k">return</span> <span class="n">lindblad_ops</span></div>

    
<div class="viewcode-block" id="NVLindblad.lindblad_rhs">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVLindblad.lindblad_rhs">[docs]</a>
    <span class="k">def</span> <span class="nf">lindblad_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                     <span class="n">include_noise_sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute right-hand side of the Lindblad master equation.</span>
<span class="sd">        </span>
<span class="sd">        Evaluates dρ/dt for the Lindblad equation at time t. This function</span>
<span class="sd">        is designed to be used with scipy&#39;s ODE integrators.</span>
<span class="sd">        </span>
<span class="sd">        The Lindblad equation is:</span>
<span class="sd">            dρ/dt = -i/ℏ[H,ρ] + Σ_k γ_k·D[L_k](ρ)</span>
<span class="sd">            </span>
<span class="sd">        where D[L](ρ) = L·ρ·L† - {L†·L,ρ}/2 is the dissipator.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            t: Time in seconds at which to evaluate the derivative.</span>
<span class="sd">            rho_vec: Density matrix as a flattened complex vector (length 9).</span>
<span class="sd">            include_noise_sources: Noise sources to include in evolution.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Time derivative dρ/dt as flattened vector.</span>
<span class="sd">            </span>
<span class="sd">        Notes:</span>
<span class="sd">            - The density matrix is vectorized for ODE solver compatibility</span>
<span class="sd">            - Ensures trace preservation and Hermiticity</span>
<span class="sd">            - Computational complexity is O(n³) for n-level system</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reshape to matrix form</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">rho_vec</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        
        <span class="c1"># Get time-dependent Hamiltonian</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">get_total_hamiltonian</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">include_noise_sources</span><span class="p">)</span>
        
        <span class="c1"># Coherent evolution: -i[H, ρ]/ℏ</span>
        <span class="n">hbar</span> <span class="o">=</span> <span class="n">SYSTEM</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="s1">&#39;fundamental&#39;</span><span class="p">,</span> <span class="s1">&#39;hbar&#39;</span><span class="p">)</span>
        <span class="n">commutator</span> <span class="o">=</span> <span class="n">H</span> <span class="o">@</span> <span class="n">rho</span> <span class="o">-</span> <span class="n">rho</span> <span class="o">@</span> <span class="n">H</span>
        <span class="n">drho_dt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">commutator</span> <span class="o">/</span> <span class="n">hbar</span>
        
        <span class="c1"># Dissipative evolution: Lindblad terms</span>
        <span class="n">lindblad_ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lindblad_operators</span><span class="p">(</span><span class="n">include_noise_sources</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">L</span><span class="p">,</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="n">lindblad_ops</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gamma</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># D[L]ρ = LρL† - (1/2){L†L, ρ}</span>
                <span class="n">L_dag</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
                <span class="n">L_dag_L</span> <span class="o">=</span> <span class="n">L_dag</span> <span class="o">@</span> <span class="n">L</span>
                
                <span class="c1"># Lindblad superoperator action</span>
                <span class="n">drho_dt</span> <span class="o">+=</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">L</span> <span class="o">@</span> <span class="n">rho</span> <span class="o">@</span> <span class="n">L_dag</span> <span class="o">-</span> 
                    <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">L_dag_L</span> <span class="o">@</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">@</span> <span class="n">L_dag_L</span><span class="p">)</span>
                <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">drho_dt</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="NVLindblad.evolve">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVLindblad.evolve">[docs]</a>
    <span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_span</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> 
               <span class="n">dt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
               <span class="n">include_noise_sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;RK45&#39;</span><span class="p">,</span>
               <span class="n">rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
               <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evolve density matrix using the Lindblad master equation.</span>
<span class="sd">        </span>
<span class="sd">        Integrates the Lindblad equation from initial state rho0 over the</span>
<span class="sd">        specified time interval. Uses adaptive timestepping for accuracy.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rho0: Initial density matrix (3x3 complex array).</span>
<span class="sd">                 Must be Hermitian with trace 1.</span>
<span class="sd">            t_span: Time interval (t_start, t_end) in seconds.</span>
<span class="sd">            dt: Time step for output points. If None, uses noise generator dt</span>
<span class="sd">                or 1 ps default. Note: actual integration uses adaptive steps.</span>
<span class="sd">            include_noise_sources: List of noise sources to include.</span>
<span class="sd">                                 None means all enabled sources.</span>
<span class="sd">            method: ODE integration method. Options: &#39;RK45&#39;, &#39;RK23&#39;, &#39;DOP853&#39;.</span>
<span class="sd">                   &#39;RK45&#39; is usually best for this problem.</span>
<span class="sd">            rtol: Relative tolerance for integration (default 1e-6).</span>
<span class="sd">            atol: Absolute tolerance for integration (default 1e-8).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray, List[np.ndarray]]: </span>
<span class="sd">                - times: Array of time points</span>
<span class="sd">                - rho_history: List of density matrices at each time</span>
<span class="sd">                </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If rho0 is not a valid density matrix.</span>
<span class="sd">            RuntimeError: If integration fails to converge.</span>
<span class="sd">            </span>
<span class="sd">        Notes:</span>
<span class="sd">            - The integrator uses adaptive timestepping internally</span>
<span class="sd">            - Output is sampled at fixed dt intervals</span>
<span class="sd">            - Total probability (trace) is conserved to numerical precision</span>
<span class="sd">            - For long simulations, consider using larger dt to save memory</span>
<span class="sd">            </span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Evolve from superposition state</span>
<span class="sd">            &gt;&gt;&gt; psi0 = (nv.states[&#39;ms0&#39;] + nv.states[&#39;ms+1&#39;]) / np.sqrt(2)</span>
<span class="sd">            &gt;&gt;&gt; rho0 = np.outer(psi0, psi0.conj())</span>
<span class="sd">            &gt;&gt;&gt; times, rhos = lindblad.evolve(rho0, (0, 10e-6), dt=1e-9)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Check trace preservation</span>
<span class="sd">            &gt;&gt;&gt; traces = [np.trace(rho) for rho in rhos]</span>
<span class="sd">            &gt;&gt;&gt; np.allclose(traces, 1.0)</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate initial state</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">rho0</span><span class="p">,</span> <span class="n">rho0</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Initial density matrix must be Hermitian&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rho0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trace of rho0 is </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rho0</span><span class="p">)</span><span class="si">}</span><span class="s2">, normalizing to 1&quot;</span><span class="p">)</span>
            <span class="n">rho0</span> <span class="o">=</span> <span class="n">rho0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rho0</span><span class="p">)</span>
            
        <span class="c1"># Determine time step</span>
        <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">noise_gen</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">noise_gen</span><span class="o">.</span><span class="n">config</span><span class="p">,</span> <span class="s1">&#39;dt&#39;</span><span class="p">):</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">noise_gen</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">dt</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="mf">1e-11</span>  <span class="c1"># 10 ps default</span>
                
        <span class="c1"># Create evaluation time points</span>
        <span class="n">t_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">t_span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_span</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t_eval</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t_span</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">t_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">t_span</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Solve the master equation</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lindblad_rhs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">include_noise_sources</span><span class="p">),</span>
                <span class="n">t_span</span><span class="p">,</span>
                <span class="n">rho0</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">),</span>
                <span class="n">t_eval</span><span class="o">=</span><span class="n">t_eval</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
                <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
                <span class="n">max_step</span><span class="o">=</span><span class="n">dt</span><span class="o">*</span><span class="mi">10</span>  <span class="c1"># Limit max step size</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Integration failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Integration failed: </span><span class="si">{</span><span class="n">sol</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Reshape solutions back to density matrices</span>
        <span class="n">rho_history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">)):</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="c1"># Ensure Hermiticity (may have small numerical errors)</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span> <span class="o">+</span> <span class="n">rho</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="c1"># Ensure trace = 1</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">rho_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_history</span></div>

    
<div class="viewcode-block" id="NVLindblad.evolve_with_pulses">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVLindblad.evolve_with_pulses">[docs]</a>
    <span class="k">def</span> <span class="nf">evolve_with_pulses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pulse_sequence</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span>
                          <span class="n">include_noise_sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">evolve_kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evolve system with a sequence of microwave pulses.</span>
<span class="sd">        </span>
<span class="sd">        Simulates the evolution under a series of microwave pulses, each</span>
<span class="sd">        potentially having different Rabi frequency, phase, and duration.</span>
<span class="sd">        Between pulses, the system undergoes free evolution.</span>
<span class="sd">        </span>
<span class="sd">        Pulses are implemented by adding an oscillating magnetic field</span>
<span class="sd">        term to the Hamiltonian. In the rotating frame, this becomes</span>
<span class="sd">        an effective static field.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rho0: Initial density matrix.</span>
<span class="sd">            pulse_sequence: List of pulse dictionaries, each containing:</span>
<span class="sd">                - &#39;duration&#39;: Pulse duration in seconds (required)</span>
<span class="sd">                - &#39;rabi_frequency&#39;: Rabi frequency in Hz (default 0)</span>
<span class="sd">                - &#39;phase&#39;: Pulse phase in radians (default 0)</span>
<span class="sd">                - &#39;detuning&#39;: Frequency detuning in Hz (default 0)</span>
<span class="sd">                - &#39;amplitude&#39;: Optional amplitude modulation function</span>
<span class="sd">            include_noise_sources: Noise sources to include during evolution.</span>
<span class="sd">            **evolve_kwargs: Additional arguments passed to evolve()</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray, List[np.ndarray]]:</span>
<span class="sd">                - times: Concatenated time array for entire sequence</span>
<span class="sd">                - rho_history: Density matrices for entire sequence</span>
<span class="sd">                </span>
<span class="sd">        Notes:</span>
<span class="sd">            - Pulses are applied in the rotating wave approximation</span>
<span class="sd">            - Microwave noise can modulate pulse parameters if enabled</span>
<span class="sd">            - Total evolution time is sum of all pulse durations</span>
<span class="sd">            - Phase convention: 0 = X pulse, π/2 = Y pulse</span>
<span class="sd">            </span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Rabi oscillation</span>
<span class="sd">            &gt;&gt;&gt; rabi_pulse = [{</span>
<span class="sd">            ...     &#39;duration&#39;: 1e-6,</span>
<span class="sd">            ...     &#39;rabi_frequency&#39;: 10e6,  # 10 MHz</span>
<span class="sd">            ...     &#39;phase&#39;: 0</span>
<span class="sd">            ... }]</span>
<span class="sd">            &gt;&gt;&gt; times, rhos = lindblad.evolve_with_pulses(rho0, rabi_pulse)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Ramsey sequence</span>
<span class="sd">            &gt;&gt;&gt; ramsey = [</span>
<span class="sd">            ...     {&#39;duration&#39;: 25e-9, &#39;rabi_frequency&#39;: 10e6},  # π/2</span>
<span class="sd">            ...     {&#39;duration&#39;: 1e-6, &#39;rabi_frequency&#39;: 0},      # Free evolution</span>
<span class="sd">            ...     {&#39;duration&#39;: 25e-9, &#39;rabi_frequency&#39;: 10e6}   # π/2</span>
<span class="sd">            ... ]</span>
<span class="sd">            &gt;&gt;&gt; times, rhos = lindblad.evolve_with_pulses(rho0, ramsey)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_rho</span> <span class="o">=</span> <span class="n">rho0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">all_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_rhos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="mf">0.0</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pulse_sequence</span><span class="p">):</span>
            <span class="c1"># Extract pulse parameters</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">pulse</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span>
            <span class="n">rabi</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rabi_frequency&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">detuning</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;detuning&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            
            <span class="c1"># Apply microwave noise if enabled</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">noise_gen</span> <span class="ow">and</span> 
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">noise_gen</span><span class="p">,</span> <span class="s1">&#39;sources&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="s1">&#39;microwave&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">noise_gen</span><span class="o">.</span><span class="n">sources</span><span class="p">):</span>
                <span class="c1"># Noise can modify pulse parameters</span>
                <span class="n">pulse_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">noise_gen</span><span class="o">.</span><span class="n">process_microwave_pulse</span><span class="p">(</span>
                    <span class="n">rabi</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">phase</span>
                <span class="p">)</span>
                <span class="c1"># Use average values for simplicity (could be extended)</span>
                <span class="n">rabi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pulse_params</span><span class="p">[</span><span class="s1">&#39;rabi_frequency&#39;</span><span class="p">])</span>
                <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pulse_params</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">])</span>
                <span class="n">detuning</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pulse_params</span><span class="p">[</span><span class="s1">&#39;frequency_offset&#39;</span><span class="p">])</span>
            
            <span class="c1"># Store original field</span>
            <span class="n">original_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">B_static</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="c1"># Add effective microwave field (rotating wave approximation)</span>
            <span class="k">if</span> <span class="n">rabi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># In rotating frame, MW appears as static transverse field</span>
                <span class="n">B_mw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                    <span class="n">rabi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">gamma_e</span><span class="p">,</span>
                    <span class="n">rabi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">gamma_e</span><span class="p">,</span>
                    <span class="n">detuning</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">gamma_e</span>
                <span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">B_static</span> <span class="o">=</span> <span class="n">original_B</span> <span class="o">+</span> <span class="n">B_mw</span>
            
            <span class="c1"># Evolve during pulse</span>
            <span class="n">t_span</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_time</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">+</span> <span class="n">duration</span><span class="p">)</span>
            <span class="n">times</span><span class="p">,</span> <span class="n">rhos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span>
                <span class="n">current_rho</span><span class="p">,</span> <span class="n">t_span</span><span class="p">,</span> 
                <span class="n">include_noise_sources</span><span class="o">=</span><span class="n">include_noise_sources</span><span class="p">,</span>
                <span class="o">**</span><span class="n">evolve_kwargs</span>
            <span class="p">)</span>
            
            <span class="c1"># Append results (avoiding duplicate time points)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Skip first point to avoid duplication</span>
                <span class="n">all_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">all_rhos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rhos</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
                <span class="n">all_rhos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rhos</span><span class="p">)</span>
            
            <span class="c1"># Update state and time</span>
            <span class="n">current_rho</span> <span class="o">=</span> <span class="n">rhos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">current_time</span> <span class="o">+=</span> <span class="n">duration</span>
            
            <span class="c1"># Restore original field</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">B_static</span> <span class="o">=</span> <span class="n">original_B</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_times</span><span class="p">),</span> <span class="n">all_rhos</span></div>
</div>



<div class="viewcode-block" id="NVSystem">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem">[docs]</a>
<span class="k">class</span> <span class="nc">NVSystem</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Complete NV center quantum system with integrated functionality.</span>
<span class="sd">    </span>
<span class="sd">    This is the main class for simulating NV center dynamics. It combines:</span>
<span class="sd">    - Hamiltonian construction (NVSystemHamiltonian)</span>
<span class="sd">    - Open system evolution (NVLindblad)</span>
<span class="sd">    - Noise modeling (NoiseGenerator)</span>
<span class="sd">    - Common pulse sequences and protocols</span>
<span class="sd">    - Measurement and analysis tools</span>
<span class="sd">    - Visualization capabilities</span>
<span class="sd">    </span>
<span class="sd">    The class provides a high-level interface for common NV experiments</span>
<span class="sd">    including Rabi oscillations, Ramsey interferometry, spin echo sequences,</span>
<span class="sd">    and T1/T2 measurements.</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        noise_gen (NoiseGenerator): Noise generator instance</span>
<span class="sd">        hamiltonian (NVSystemHamiltonian): System Hamiltonian</span>
<span class="sd">        lindblad (NVLindblad): Lindblad evolution manager</span>
<span class="sd">        states (dict): Common quantum states as vectors</span>
<span class="sd">        evolve: Direct access to lindblad.evolve method</span>
<span class="sd">        evolve_with_pulses: Direct access to lindblad.evolve_with_pulses</span>
<span class="sd">        </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Create NV system with custom noise</span>
<span class="sd">        &gt;&gt;&gt; config = NoiseConfiguration()</span>
<span class="sd">        &gt;&gt;&gt; config.enable_c13_bath = True</span>
<span class="sd">        &gt;&gt;&gt; nv = NVSystem(B_field=[0, 0, 0.01], noise_config=config)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Simulate T2* measurement</span>
<span class="sd">        &gt;&gt;&gt; tau_values, coherences = nv.simulate_t2_measurement()</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Run custom pulse sequence</span>
<span class="sd">        &gt;&gt;&gt; rho0 = nv.create_initial_state(&#39;ms0&#39;)</span>
<span class="sd">        &gt;&gt;&gt; times, rhos = nv.evolve_with_pulses(rho0, pulse_sequence)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="NVSystem.__init__">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">noise_config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NoiseConfiguration</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">noise_gen</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NoiseGenerator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize complete NV system.</span>
<span class="sd">        </span>
<span class="sd">        Creates a full NV center simulation environment with specified</span>
<span class="sd">        magnetic field and noise configuration.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            B_field: Static magnetic field [Bx, By, Bz] in Tesla.</span>
<span class="sd">                    Default is zero field.</span>
<span class="sd">            noise_config: NoiseConfiguration instance specifying which</span>
<span class="sd">                         noise sources to enable. If None, no noise.</span>
<span class="sd">            noise_gen: Alternative way to specify noise using a</span>
<span class="sd">                      pre-configured NoiseGenerator. Takes precedence</span>
<span class="sd">                      over noise_config if both are provided.</span>
<span class="sd">                      </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If both noise_config and noise_gen are specified.</span>
<span class="sd">            </span>
<span class="sd">        Notes:</span>
<span class="sd">            - Use noise_config for new simulations</span>
<span class="sd">            - Use noise_gen for compatibility or special configurations</span>
<span class="sd">            - Common configs available via NoiseConfiguration.from_preset()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle noise configuration</span>
        <span class="k">if</span> <span class="n">noise_gen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">noise_config</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specify either noise_config or noise_gen, not both&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">noise_gen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_gen</span> <span class="o">=</span> <span class="n">noise_gen</span>
        <span class="k">elif</span> <span class="n">noise_config</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_gen</span> <span class="o">=</span> <span class="n">NoiseGenerator</span><span class="p">(</span><span class="n">noise_config</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_gen</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Initialize components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">NVSystemHamiltonian</span><span class="p">(</span><span class="n">B_field</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_gen</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lindblad</span> <span class="o">=</span> <span class="n">NVLindblad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="p">)</span>
        
        <span class="c1"># Convenience methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evolve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lindblad</span><span class="o">.</span><span class="n">evolve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evolve_with_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lindblad</span><span class="o">.</span><span class="n">evolve_with_pulses</span>
        
        <span class="c1"># Common quantum states (as vectors)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;ms0&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">),</span>      <span class="c1"># |ms=0⟩</span>
            <span class="s1">&#39;ms+1&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">),</span>     <span class="c1"># |ms=+1⟩  </span>
            <span class="s1">&#39;ms-1&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">),</span>     <span class="c1"># |ms=-1⟩</span>
            <span class="s1">&#39;superposition&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>  <span class="c1"># (|0⟩+|+1⟩)/√2</span>
            <span class="s1">&#39;ghz&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>  <span class="c1"># (|-1⟩+|+1⟩)/√2</span>
        <span class="p">}</span></div>

        
<div class="viewcode-block" id="NVSystem.create_initial_state">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.create_initial_state">[docs]</a>
    <span class="k">def</span> <span class="nf">create_initial_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> 
                           <span class="n">pure</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an initial density matrix.</span>
<span class="sd">        </span>
<span class="sd">        Convenience method for creating common initial states as density</span>
<span class="sd">        matrices. Supports both pure and mixed states.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            state: Either a string key from self.states (&#39;ms0&#39;, &#39;ms+1&#39;, etc.)</span>
<span class="sd">                  or a 3-element state vector.</span>
<span class="sd">            pure: If True, creates pure state |ψ⟩⟨ψ|. If False, creates</span>
<span class="sd">                 maximally mixed state in the subspace.</span>
<span class="sd">                 </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: 3x3 density matrix.</span>
<span class="sd">            </span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Pure |ms=0⟩ state</span>
<span class="sd">            &gt;&gt;&gt; rho0 = nv.create_initial_state(&#39;ms0&#39;)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Superposition state</span>
<span class="sd">            &gt;&gt;&gt; rho0 = nv.create_initial_state(&#39;superposition&#39;)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Custom state vector</span>
<span class="sd">            &gt;&gt;&gt; psi = np.array([1, 2, 1]) / np.sqrt(6)</span>
<span class="sd">            &gt;&gt;&gt; rho0 = nv.create_initial_state(psi)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown state &#39;</span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2">&#39;. Options: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">psi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;State vector must be 3D, got shape </span><span class="si">{</span><span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">psi</span> <span class="o">=</span> <span class="n">psi</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>  <span class="c1"># Normalize</span>
            
        <span class="k">if</span> <span class="n">pure</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">psi</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mixed state in subspace spanned by non-zero elements</span>
            <span class="n">support</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">psi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">support</span><span class="p">:</span>
                <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">support</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rho</span></div>

        
<div class="viewcode-block" id="NVSystem.get_state_populations">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.get_state_populations">[docs]</a>
    <span class="k">def</span> <span class="nf">get_state_populations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract populations of computational basis states.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rho: Density matrix (3x3).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Dict[str, float]: Populations with keys &#39;ms-1&#39;, &#39;ms0&#39;, &#39;ms+1&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; pops = nv.get_state_populations(rho)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;ms=0 population: {pops[&#39;ms0&#39;]:.3f}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;ms-1&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
            <span class="s1">&#39;ms0&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">rho</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> 
            <span class="s1">&#39;ms+1&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">rho</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="p">}</span></div>

    
<div class="viewcode-block" id="NVSystem.get_coherences">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.get_coherences">[docs]</a>
    <span class="k">def</span> <span class="nf">get_coherences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">complex</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract quantum coherences (off-diagonal elements).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rho: Density matrix (3x3).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Dict[str, complex]: Coherences with keys like &#39;c_01&#39; for ρ₀₁.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;c_-10&#39;</span><span class="p">:</span> <span class="n">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># ⟨ms=-1|ρ|ms=0⟩</span>
            <span class="s1">&#39;c_-1+1&#39;</span><span class="p">:</span> <span class="n">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="c1"># ⟨ms=-1|ρ|ms=+1⟩</span>
            <span class="s1">&#39;c_0+1&#39;</span><span class="p">:</span> <span class="n">rho</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  <span class="c1"># ⟨ms=0|ρ|ms=+1⟩</span>
        <span class="p">}</span></div>

    
<div class="viewcode-block" id="NVSystem.measure_observable">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.measure_observable">[docs]</a>
    <span class="k">def</span> <span class="nf">measure_observable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">observable</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Measure expectation value of an observable.</span>
<span class="sd">        </span>
<span class="sd">        Computes ⟨O⟩ = Tr(ρ·O) for observable O.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rho: Density matrix.</span>
<span class="sd">            observable: Observable as 3x3 Hermitian matrix.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: Expectation value (real).</span>
<span class="sd">            </span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Measure Sz</span>
<span class="sd">            &gt;&gt;&gt; sz_exp = nv.measure_observable(rho, nv.hamiltonian.spin_ops.Sz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rho</span> <span class="o">@</span> <span class="n">observable</span><span class="p">))</span></div>

    
<div class="viewcode-block" id="NVSystem.calculate_purity">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.calculate_purity">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_purity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate purity Tr(ρ²) of quantum state.</span>
<span class="sd">        </span>
<span class="sd">        Purity ranges from 1/3 (maximally mixed) to 1 (pure state).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rho: Density matrix.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: Purity value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rho</span> <span class="o">@</span> <span class="n">rho</span><span class="p">))</span></div>

    
<div class="viewcode-block" id="NVSystem.calculate_fidelity">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.calculate_fidelity">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_fidelity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">rho2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate fidelity between two quantum states.</span>
<span class="sd">        </span>
<span class="sd">        For pure states, fidelity = |⟨ψ₁|ψ₂⟩|².</span>
<span class="sd">        General formula: F = [Tr(√(√ρ₁·ρ₂·√ρ₁))]²</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rho1: First density matrix.</span>
<span class="sd">            rho2: Second density matrix.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: Fidelity between 0 and 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Simplified for common case where one state is pure</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">rho1</span> <span class="o">@</span> <span class="n">rho1</span><span class="p">,</span> <span class="n">rho1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">rho2</span> <span class="o">@</span> <span class="n">rho2</span><span class="p">,</span> <span class="n">rho2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rho1</span> <span class="o">@</span> <span class="n">rho2</span><span class="p">))</span>
            
        <span class="c1"># General case requires matrix square root</span>
        <span class="n">sqrt_rho1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">sqrtm</span><span class="p">(</span><span class="n">rho1</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">sqrt_rho1</span> <span class="o">@</span> <span class="n">rho2</span> <span class="o">@</span> <span class="n">sqrt_rho1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">sqrtm</span><span class="p">(</span><span class="n">M</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span></div>

    
<div class="viewcode-block" id="NVSystem.create_pulse">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.create_pulse">[docs]</a>
    <span class="k">def</span> <span class="nf">create_pulse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> 
                    <span class="n">rabi_freq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10e6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a rotation pulse around specified axis.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            angle: Rotation angle in radians (π = pi pulse).</span>
<span class="sd">            axis: Rotation axis (&#39;x&#39;, &#39;y&#39;, or angle for arbitrary).</span>
<span class="sd">            rabi_freq: Rabi frequency in Hz.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Dict: Pulse dictionary for use with evolve_with_pulses.</span>
<span class="sd">            </span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # π/2 pulse around X</span>
<span class="sd">            &gt;&gt;&gt; pulse = nv.create_pulse(np.pi/2, axis=&#39;x&#39;)</span>
<span class="sd">            &gt;&gt;&gt; # π pulse around Y  </span>
<span class="sd">            &gt;&gt;&gt; pulse = nv.create_pulse(np.pi, axis=&#39;y&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">rabi_freq</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">phase</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis must be &#39;x&#39;, &#39;y&#39;, or a phase angle&quot;</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
            <span class="s1">&#39;rabi_frequency&#39;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">rabi_freq</span><span class="p">,</span>
            <span class="s1">&#39;phase&#39;</span><span class="p">:</span> <span class="n">phase</span><span class="p">,</span>
            <span class="s1">&#39;detuning&#39;</span><span class="p">:</span> <span class="mi">0</span>
        <span class="p">}</span></div>

    
<div class="viewcode-block" id="NVSystem.create_ramsey_sequence">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.create_ramsey_sequence">[docs]</a>
    <span class="k">def</span> <span class="nf">create_ramsey_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T_ramsey</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
                              <span class="n">rabi_freq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10e6</span><span class="p">,</span>
                              <span class="n">phase2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create Ramsey interferometry sequence.</span>
<span class="sd">        </span>
<span class="sd">        Sequence: π/2 - free evolution - π/2(phase)</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            T_ramsey: Free evolution time in seconds.</span>
<span class="sd">            rabi_freq: Rabi frequency for π/2 pulses.</span>
<span class="sd">            phase2: Phase of second π/2 pulse (0 for standard Ramsey).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            List[Dict]: Pulse sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pi_half</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_pulse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">rabi_freq</span><span class="o">=</span><span class="n">rabi_freq</span><span class="p">)</span>
        <span class="n">wait</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="n">T_ramsey</span><span class="p">,</span> <span class="s1">&#39;rabi_frequency&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">pi_half_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_pulse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">phase2</span><span class="p">,</span> <span class="n">rabi_freq</span><span class="o">=</span><span class="n">rabi_freq</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">[</span><span class="n">pi_half</span><span class="p">,</span> <span class="n">wait</span><span class="p">,</span> <span class="n">pi_half_2</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="NVSystem.create_echo_sequence">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.create_echo_sequence">[docs]</a>
    <span class="k">def</span> <span class="nf">create_echo_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                           <span class="n">rabi_freq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10e6</span><span class="p">,</span>
                           <span class="n">echo_axis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create Hahn echo sequence.</span>
<span class="sd">        </span>
<span class="sd">        Sequence: π/2(x) - τ - π(echo_axis) - τ - π/2(x)</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            tau: Half of the total evolution time.</span>
<span class="sd">            rabi_freq: Rabi frequency for pulses.</span>
<span class="sd">            echo_axis: Axis for π pulse (&#39;x&#39; or &#39;y&#39;).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            List[Dict]: Pulse sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pi_half_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_pulse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">rabi_freq</span><span class="o">=</span><span class="n">rabi_freq</span><span class="p">)</span>
        <span class="n">wait1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="n">tau</span><span class="p">,</span> <span class="s1">&#39;rabi_frequency&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">pi_pulse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_pulse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">echo_axis</span><span class="p">,</span> <span class="n">rabi_freq</span><span class="o">=</span><span class="n">rabi_freq</span><span class="p">)</span>
        <span class="n">wait2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="n">tau</span><span class="p">,</span> <span class="s1">&#39;rabi_frequency&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">pi_half_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_pulse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">rabi_freq</span><span class="o">=</span><span class="n">rabi_freq</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">[</span><span class="n">pi_half_1</span><span class="p">,</span> <span class="n">wait1</span><span class="p">,</span> <span class="n">pi_pulse</span><span class="p">,</span> <span class="n">wait2</span><span class="p">,</span> <span class="n">pi_half_2</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="NVSystem.create_cpmg_sequence">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.create_cpmg_sequence">[docs]</a>
    <span class="k">def</span> <span class="nf">create_cpmg_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n_pulses</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                           <span class="n">rabi_freq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10e6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create Carr-Purcell-Meiboom-Gill (CPMG) sequence.</span>
<span class="sd">        </span>
<span class="sd">        Sequence: π/2(x) - [τ - π(y) - τ]ⁿ - π/2(x)</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            tau: Time between π pulses.</span>
<span class="sd">            n_pulses: Number of π pulses.</span>
<span class="sd">            rabi_freq: Rabi frequency.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            List[Dict]: Pulse sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">create_pulse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">rabi_freq</span><span class="o">=</span><span class="n">rabi_freq</span><span class="p">)]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pulses</span><span class="p">):</span>
            <span class="n">sequence</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;rabi_frequency&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
            <span class="n">sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">create_pulse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">rabi_freq</span><span class="o">=</span><span class="n">rabi_freq</span><span class="p">))</span>
            <span class="n">sequence</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;rabi_frequency&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
            
        <span class="n">sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">create_pulse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">rabi_freq</span><span class="o">=</span><span class="n">rabi_freq</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sequence</span></div>

    
<div class="viewcode-block" id="NVSystem.simulate_rabi_oscillations">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.simulate_rabi_oscillations">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_rabi_oscillations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rabi_freq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10e6</span><span class="p">,</span>
                                 <span class="n">duration</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
                                 <span class="n">n_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate Rabi oscillations under continuous driving.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rabi_freq: Driving frequency in Hz.</span>
<span class="sd">            duration: Total evolution time.</span>
<span class="sd">            n_points: Number of time points.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray, np.ndarray]: (times, populations)</span>
<span class="sd">            where populations has shape (n_points, 3).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_initial_state</span><span class="p">(</span><span class="s1">&#39;ms0&#39;</span><span class="p">)</span>
        <span class="n">pulse</span> <span class="o">=</span> <span class="p">[{</span>
            <span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
            <span class="s1">&#39;rabi_frequency&#39;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">rabi_freq</span><span class="p">,</span>
            <span class="s1">&#39;phase&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;detuning&#39;</span><span class="p">:</span> <span class="mi">0</span>
        <span class="p">}]</span>
        
        <span class="n">times</span><span class="p">,</span> <span class="n">rhos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evolve_with_pulses</span><span class="p">(</span><span class="n">rho0</span><span class="p">,</span> <span class="n">pulse</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">duration</span><span class="o">/</span><span class="n">n_points</span><span class="p">)</span>
        
        <span class="n">populations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_state_populations</span><span class="p">(</span><span class="n">rho</span><span class="p">)[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ms-1&#39;</span><span class="p">,</span> <span class="s1">&#39;ms0&#39;</span><span class="p">,</span> <span class="s1">&#39;ms+1&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">rho</span> <span class="ow">in</span> <span class="n">rhos</span>
        <span class="p">])</span>
        
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">populations</span></div>

    
<div class="viewcode-block" id="NVSystem.simulate_t2_measurement">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.simulate_t2_measurement">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_t2_measurement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10e-6</span><span class="p">,</span> 
                               <span class="n">n_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                               <span class="n">sequence</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;ramsey&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate coherence decay measurement (T2* or T2).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            tau_max: Maximum evolution time.</span>
<span class="sd">            n_points: Number of tau values to sample.</span>
<span class="sd">            sequence: &#39;ramsey&#39; for T2* or &#39;echo&#39; for T2.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray, np.ndarray]: (tau_values, coherences)</span>
<span class="sd">            </span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Measure T2*</span>
<span class="sd">            &gt;&gt;&gt; taus, coherences = nv.simulate_t2_measurement(sequence=&#39;ramsey&#39;)</span>
<span class="sd">            &gt;&gt;&gt; # Fit exponential decay</span>
<span class="sd">            &gt;&gt;&gt; from scipy.optimize import curve_fit</span>
<span class="sd">            &gt;&gt;&gt; popt, _ = curve_fit(lambda t, A, T2: A*np.exp(-t/T2), taus, coherences)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;T2* = {popt[1]*1e6:.1f} μs&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tau_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tau_max</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
        <span class="n">coherences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
        
        <span class="c1"># Initial state: |ms=0⟩</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_initial_state</span><span class="p">(</span><span class="s1">&#39;ms0&#39;</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tau</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tau_values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sequence</span> <span class="o">==</span> <span class="s1">&#39;ramsey&#39;</span><span class="p">:</span>
                <span class="n">pulse_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_ramsey_sequence</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">sequence</span> <span class="o">==</span> <span class="s1">&#39;echo&#39;</span><span class="p">:</span>
                <span class="n">pulse_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_echo_sequence</span><span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># tau is total time</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown sequence: </span><span class="si">{</span><span class="n">sequence</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="n">times</span><span class="p">,</span> <span class="n">rhos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evolve_with_pulses</span><span class="p">(</span><span class="n">rho0</span><span class="p">,</span> <span class="n">pulse_seq</span><span class="p">)</span>
            
            <span class="c1"># Measure final state</span>
            <span class="n">final_rho</span> <span class="o">=</span> <span class="n">rhos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># For Ramsey/echo, measure ⟨Sx⟩ or population difference</span>
            <span class="n">coherences</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_observable</span><span class="p">(</span><span class="n">final_rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">spin_ops</span><span class="o">.</span><span class="n">Sx</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">tau_values</span><span class="p">,</span> <span class="n">coherences</span></div>

    
<div class="viewcode-block" id="NVSystem.simulate_t1_measurement">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.simulate_t1_measurement">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_t1_measurement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">100e-6</span><span class="p">,</span>
                               <span class="n">n_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate longitudinal relaxation (T1) measurement.</span>
<span class="sd">        </span>
<span class="sd">        Prepares |ms=+1⟩ state and measures decay to |ms=0⟩.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            t_max: Maximum wait time.</span>
<span class="sd">            n_points: Number of time points.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray, np.ndarray]: (times, populations)</span>
<span class="sd">            where populations are for |ms=+1⟩ state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
        <span class="n">populations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
        
        <span class="c1"># Initial state: |ms=+1⟩</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_initial_state</span><span class="p">(</span><span class="s1">&#39;ms+1&#39;</span><span class="p">)</span>
        
        <span class="c1"># Evolve and sample</span>
        <span class="n">t_all</span><span class="p">,</span> <span class="n">rhos_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">rho0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="p">),</span> <span class="n">dt</span><span class="o">=</span><span class="n">t_max</span><span class="o">/</span><span class="n">n_points</span><span class="p">)</span>
        
        <span class="c1"># Extract populations at sample times</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t_all</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>
            <span class="n">pops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_state_populations</span><span class="p">(</span><span class="n">rhos_all</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">populations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pops</span><span class="p">[</span><span class="s1">&#39;ms+1&#39;</span><span class="p">]</span>
            
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">populations</span></div>

    
<div class="viewcode-block" id="NVSystem.visualize_evolution">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.visualize_evolution">[docs]</a>
    <span class="k">def</span> <span class="nf">visualize_evolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                          <span class="n">include_noise_sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">dt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">figsize</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visualize time evolution of state populations and coherences.</span>
<span class="sd">        </span>
<span class="sd">        Creates a comprehensive plot showing:</span>
<span class="sd">        - Population dynamics</span>
<span class="sd">        - Coherence evolution</span>
<span class="sd">        - Purity decay</span>
<span class="sd">        - Optional: Bloch sphere trajectory</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rho0: Initial density matrix.</span>
<span class="sd">            t_max: Evolution time in seconds.</span>
<span class="sd">            include_noise_sources: Noise sources to include.</span>
<span class="sd">            dt: Time step for evolution.</span>
<span class="sd">            figsize: Figure size (width, height).</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            fig, axes: Matplotlib figure and axes objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Evolve system</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">rhos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">rho0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="p">),</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> 
                                 <span class="n">include_noise_sources</span><span class="o">=</span><span class="n">include_noise_sources</span><span class="p">)</span>
        
        <span class="c1"># Extract quantities</span>
        <span class="n">populations</span> <span class="o">=</span> <span class="p">{</span><span class="n">state</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ms-1&#39;</span><span class="p">,</span> <span class="s1">&#39;ms0&#39;</span><span class="p">,</span> <span class="s1">&#39;ms+1&#39;</span><span class="p">]}</span>
        <span class="n">coherences</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">purities</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">rho</span> <span class="ow">in</span> <span class="n">rhos</span><span class="p">:</span>
            <span class="c1"># Populations</span>
            <span class="n">state_pops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_state_populations</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">state_pops</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">populations</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
                
            <span class="c1"># Coherences (magnitude)</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coherences</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">coherences</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
            
            <span class="c1"># Purity</span>
            <span class="n">purities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calculate_purity</span><span class="p">(</span><span class="n">rho</span><span class="p">))</span>
        
        <span class="n">coherences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coherences</span><span class="p">)</span>
        
        <span class="c1"># Create figure</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        
        <span class="c1"># Convert time to microseconds</span>
        <span class="n">times_us</span> <span class="o">=</span> <span class="n">times</span> <span class="o">*</span> <span class="mf">1e6</span>
        
        <span class="c1"># Plot populations</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">populations</span><span class="p">[</span><span class="s1">&#39;ms-1&#39;</span><span class="p">],</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$|m_s=-1</span><span class="se">\\</span><span class="s1">rangle$&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">populations</span><span class="p">[</span><span class="s1">&#39;ms0&#39;</span><span class="p">],</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$|m_s=0</span><span class="se">\\</span><span class="s1">rangle$&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">populations</span><span class="p">[</span><span class="s1">&#39;ms+1&#39;</span><span class="p">],</span> <span class="s1">&#39;g-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$|m_s=+1</span><span class="se">\\</span><span class="s1">rangle$&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (μs)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Population&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;State Populations&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">1.05</span><span class="p">)</span>
        
        <span class="c1"># Plot coherences</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">coh_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;$|</span><span class="se">\\</span><span class="s1">rho_{-1,0}|$&#39;</span><span class="p">,</span> <span class="s1">&#39;$|</span><span class="se">\\</span><span class="s1">rho_{-1,+1}|$&#39;</span><span class="p">,</span> <span class="s1">&#39;$|</span><span class="se">\\</span><span class="s1">rho_{0,+1}|$&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coh_labels</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">coherences</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (μs)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Coherence Magnitude&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Quantum Coherences&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">)</span>
        
        <span class="c1"># Plot purity</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">purities</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Pure state&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Max. mixed&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (μs)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Purity $</span><span class="se">\\</span><span class="s1">mathrm</span><span class="si">{Tr}</span><span class="s1">(</span><span class="se">\\</span><span class="s1">rho^2)$&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;State Purity&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.05</span><span class="p">)</span>
        
        <span class="c1"># Noise power spectrum or additional info</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_gen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Show active noise sources</span>
            <span class="n">active_sources</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_gen</span><span class="o">.</span><span class="n">config</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">enable_c13_bath</span><span class="p">:</span> <span class="n">active_sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;C13 bath&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">enable_charge_noise</span><span class="p">:</span> <span class="n">active_sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Charge noise&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">enable_temperature</span><span class="p">:</span> <span class="n">active_sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Temperature&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">enable_johnson</span><span class="p">:</span> <span class="n">active_sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Johnson noise&#39;</span><span class="p">)</span>
            
            <span class="n">info_text</span> <span class="o">=</span> <span class="s2">&quot;Active Noise Sources:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;• </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">active_sources</span><span class="p">)</span>
            <span class="n">info_text</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Magnetic field: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">B_static</span><span class="o">*</span><span class="mf">1e3</span><span class="si">}</span><span class="s2"> mT&quot;</span>
            <span class="n">info_text</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Simulation time: </span><span class="si">{</span><span class="n">t_max</span><span class="o">*</span><span class="mf">1e6</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> μs&quot;</span>
            
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">info_text</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span> 
                   <span class="n">fontsize</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                   <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;wheat&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;No noise sources active</span><span class="se">\n</span><span class="s1">(Ideal system)&#39;</span><span class="p">,</span> 
                   <span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                   <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;italic&#39;</span><span class="p">)</span>
                   
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Simulation Info&#39;</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;NV Center Quantum Evolution&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span></div>

    
<div class="viewcode-block" id="NVSystem.benchmark_performance">
<a class="viewcode-back" href="../api_reference.html#nvcore.NVSystem.benchmark_performance">[docs]</a>
    <span class="k">def</span> <span class="nf">benchmark_performance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Benchmark simulation performance.</span>
<span class="sd">        </span>
<span class="sd">        Runs test simulations to measure:</span>
<span class="sd">        - Integration speed</span>
<span class="sd">        - Memory usage</span>
<span class="sd">        - Numerical accuracy</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            t_max: Simulation time for benchmark.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Dict: Performance metrics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">time</span>
        <span class="kn">import</span> <span class="nn">tracemalloc</span>
        
        <span class="n">metrics</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_initial_state</span><span class="p">(</span><span class="s1">&#39;superposition&#39;</span><span class="p">)</span>
        
        <span class="c1"># Time simulation</span>
        <span class="n">tracemalloc</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="n">times</span><span class="p">,</span> <span class="n">rhos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">rho0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="p">))</span>
        
        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="n">current</span><span class="p">,</span> <span class="n">peak</span> <span class="o">=</span> <span class="n">tracemalloc</span><span class="o">.</span><span class="n">get_traced_memory</span><span class="p">()</span>
        <span class="n">tracemalloc</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
        
        <span class="c1"># Compute metrics</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;wall_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elapsed</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;simulated_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_max</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;speedup&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_max</span> <span class="o">/</span> <span class="n">elapsed</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;time_points&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;memory_peak_mb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peak</span> <span class="o">/</span> <span class="mf">1e6</span>
        
        <span class="c1"># Check accuracy (trace preservation)</span>
        <span class="n">trace_errors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">rho</span> <span class="ow">in</span> <span class="n">rhos</span><span class="p">[::</span><span class="mi">10</span><span class="p">]]</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;max_trace_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">trace_errors</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;mean_trace_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">trace_errors</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">metrics</span></div>
</div>



<span class="c1"># Convenience functions for common scenarios</span>

<div class="viewcode-block" id="create_room_temperature_nv">
<a class="viewcode-back" href="../api_reference.html#nvcore.create_room_temperature_nv">[docs]</a>
<span class="k">def</span> <span class="nf">create_room_temperature_nv</span><span class="p">(</span><span class="n">B_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NVSystem</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create NV system with typical room temperature noise.</span>
<span class="sd">    </span>
<span class="sd">    Enables noise sources relevant at 300K:</span>
<span class="sd">    - C13 nuclear spin bath</span>
<span class="sd">    - Charge noise from surface states</span>
<span class="sd">    - Temperature fluctuations</span>
<span class="sd">    - Johnson noise from electrodes</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        B_field: Static magnetic field in Tesla.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        NVSystem: Configured for room temperature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">NoiseConfiguration</span><span class="o">.</span><span class="n">from_preset</span><span class="p">(</span><span class="s1">&#39;room_temperature&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">NVSystem</span><span class="p">(</span><span class="n">B_field</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span></div>


<div class="viewcode-block" id="create_cryogenic_nv">
<a class="viewcode-back" href="../api_reference.html#nvcore.create_cryogenic_nv">[docs]</a>
<span class="k">def</span> <span class="nf">create_cryogenic_nv</span><span class="p">(</span><span class="n">B_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                       <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NVSystem</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create NV system for cryogenic conditions.</span>
<span class="sd">    </span>
<span class="sd">    Optimized for low temperature (typically 4K) with reduced:</span>
<span class="sd">    - Thermal phonon noise</span>
<span class="sd">    - Charge state fluctuations</span>
<span class="sd">    - Temperature variations</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        B_field: Static magnetic field in Tesla.</span>
<span class="sd">        temperature: Operating temperature in Kelvin.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        NVSystem: Configured for cryogenic operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">NoiseConfiguration</span><span class="o">.</span><span class="n">from_preset</span><span class="p">(</span><span class="s1">&#39;cryogenic&#39;</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="n">temperature</span>
    <span class="k">return</span> <span class="n">NVSystem</span><span class="p">(</span><span class="n">B_field</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span></div>


<div class="viewcode-block" id="create_low_noise_nv">
<a class="viewcode-back" href="../api_reference.html#nvcore.create_low_noise_nv">[docs]</a>
<span class="k">def</span> <span class="nf">create_low_noise_nv</span><span class="p">(</span><span class="n">B_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NVSystem</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create NV system with minimal noise for testing.</span>
<span class="sd">    </span>
<span class="sd">    Only essential noise sources enabled:</span>
<span class="sd">    - Weak C13 bath coupling</span>
<span class="sd">    - Minimal charge noise</span>
<span class="sd">    </span>
<span class="sd">    Useful for:</span>
<span class="sd">    - Algorithm development</span>
<span class="sd">    - Identifying noise-limited features</span>
<span class="sd">    - Fast simulations</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        B_field: Static magnetic field in Tesla.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        NVSystem: Low-noise configuration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">NoiseConfiguration</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">enable_c13_bath</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">config</span><span class="o">.</span><span class="n">c13_concentration</span> <span class="o">=</span> <span class="mf">0.001</span>  <span class="c1"># 0.1% concentration</span>
    <span class="n">config</span><span class="o">.</span><span class="n">enable_charge_noise</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">config</span><span class="o">.</span><span class="n">charge_noise_strength</span> <span class="o">=</span> <span class="mf">1e3</span>  <span class="c1"># Weak coupling</span>
    <span class="c1"># Disable other sources</span>
    <span class="n">config</span><span class="o">.</span><span class="n">enable_temperature</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">config</span><span class="o">.</span><span class="n">enable_johnson</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">config</span><span class="o">.</span><span class="n">enable_external_field</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">config</span><span class="o">.</span><span class="n">enable_strain</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">config</span><span class="o">.</span><span class="n">enable_microwave</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">config</span><span class="o">.</span><span class="n">enable_optical</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="k">return</span> <span class="n">NVSystem</span><span class="p">(</span><span class="n">B_field</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Example usage demonstrating key features</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;QUSIM NV Center Simulation - Example Usage&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
    
    <span class="c1"># Create system with room temperature noise</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">1. Creating NV system with room temperature noise...&quot;</span><span class="p">)</span>
    <span class="n">B_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">])</span>  <span class="c1"># 1 mT along z</span>
    <span class="n">nv_system</span> <span class="o">=</span> <span class="n">create_room_temperature_nv</span><span class="p">(</span><span class="n">B_field</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Magnetic field: </span><span class="si">{</span><span class="n">B_field</span><span class="o">*</span><span class="mf">1e3</span><span class="si">}</span><span class="s2"> mT&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Active noise sources: </span><span class="si">{</span><span class="n">nv_system</span><span class="o">.</span><span class="n">noise_gen</span><span class="o">.</span><span class="n">get_active_sources</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Simulate coherent evolution</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">2. Simulating coherent evolution from superposition state...&quot;</span><span class="p">)</span>
    <span class="n">rho0</span> <span class="o">=</span> <span class="n">nv_system</span><span class="o">.</span><span class="n">create_initial_state</span><span class="p">(</span><span class="s1">&#39;superposition&#39;</span><span class="p">)</span>
    <span class="n">times</span><span class="p">,</span> <span class="n">rhos</span> <span class="o">=</span> <span class="n">nv_system</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">rho0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">100e-9</span><span class="p">),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">)</span>
    
    <span class="n">initial_pops</span> <span class="o">=</span> <span class="n">nv_system</span><span class="o">.</span><span class="n">get_state_populations</span><span class="p">(</span><span class="n">rhos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">final_pops</span> <span class="o">=</span> <span class="n">nv_system</span><span class="o">.</span><span class="n">get_state_populations</span><span class="p">(</span><span class="n">rhos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Initial populations: </span><span class="si">{</span><span class="n">initial_pops</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Final populations: </span><span class="si">{</span><span class="n">final_pops</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Purity change: </span><span class="si">{</span><span class="n">nv_system</span><span class="o">.</span><span class="n">calculate_purity</span><span class="p">(</span><span class="n">rhos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> → &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nv_system</span><span class="o">.</span><span class="n">calculate_purity</span><span class="p">(</span><span class="n">rhos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Rabi oscillations</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">3. Simulating Rabi oscillations...&quot;</span><span class="p">)</span>
    <span class="n">times_rabi</span><span class="p">,</span> <span class="n">pops_rabi</span> <span class="o">=</span> <span class="n">nv_system</span><span class="o">.</span><span class="n">simulate_rabi_oscillations</span><span class="p">(</span>
        <span class="n">rabi_freq</span><span class="o">=</span><span class="mf">10e6</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">200e-9</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">50</span>
    <span class="p">)</span>
    <span class="n">max_transfer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pops_rabi</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># Max |+1⟩ population</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Maximum population transfer to |+1⟩: </span><span class="si">{</span><span class="n">max_transfer</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># T2* measurement</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">4. Measuring T2* with Ramsey sequence...&quot;</span><span class="p">)</span>
    <span class="n">tau_vals</span><span class="p">,</span> <span class="n">coherences</span> <span class="o">=</span> <span class="n">nv_system</span><span class="o">.</span><span class="n">simulate_t2_measurement</span><span class="p">(</span>
        <span class="n">tau_max</span><span class="o">=</span><span class="mf">5e-6</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">sequence</span><span class="o">=</span><span class="s1">&#39;ramsey&#39;</span>
    <span class="p">)</span>
    
    <span class="c1"># Fit exponential decay</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
    <span class="k">def</span> <span class="nf">exp_decay</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">T2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">T2</span><span class="p">)</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">exp_decay</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coherences</span><span class="p">),</span> <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Fitted T2*: </span><span class="si">{</span><span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1e6</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> μs&quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   T2* fitting failed - coherence decay too fast or irregular&quot;</span><span class="p">)</span>
    
    <span class="c1"># Performance benchmark</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">5. Running performance benchmark...&quot;</span><span class="p">)</span>
    <span class="n">metrics</span> <span class="o">=</span> <span class="n">nv_system</span><span class="o">.</span><span class="n">benchmark_performance</span><span class="p">(</span><span class="n">t_max</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Simulation speedup: </span><span class="si">{</span><span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;speedup&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">x realtime&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Memory usage: </span><span class="si">{</span><span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;memory_peak_mb&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> MB&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Numerical accuracy: </span><span class="si">{</span><span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;max_trace_error&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Example completed. Use nv_system.visualize_evolution() for plots.&quot;</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">QUSIM</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api_reference.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, QUSIM Development Team.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>